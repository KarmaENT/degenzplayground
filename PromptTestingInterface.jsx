import React, { useState, useEffect } from 'react';
import { FaFlask, FaCode, FaChartLine, FaStar, FaRegStar, FaClipboard, FaDownload } from 'react-icons/fa';
import './PromptTestingInterface.jsx.css';

const PromptTestingInterface = ({
  item = null,
  itemType = 'template', // 'template' or 'chain'
  availableModels = [],
  onSaveResult,
  onShareToLibrary
}) => {
  const [selectedModel, setSelectedModel] = useState('');
  const [parameters, setParameters] = useState({
    temperature: 0.7,
    max_tokens: 1024,
    top_p: 1.0,
    frequency_penalty: 0.0,
    presence_penalty: 0.0
  });
  const [variables, setVariables] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  const [testResult, setTestResult] = useState(null);
  const [rating, setRating] = useState(0);
  const [notes, setNotes] = useState('');
  const [showAdvancedParams, setShowAdvancedParams] = useState(false);
  const [copiedToClipboard, setCopiedToClipboard] = useState(false);

  // Initialize form with item data
  useEffect(() => {
    if (item) {
      // Set default model
      if (availableModels.length > 0) {
        setSelectedModel(availableModels[0].id);
      }
      
      // Initialize variables with default values
      if (itemType === 'template' && item.variables) {
        const initialVars = {};
        item.variables.forEach(variable => {
          initialVars[variable.name] = item.default_values?.[variable.name] || '';
        });
        setVariables(initialVars);
      } else if (itemType === 'chain' && item.templates?.[0]?.variables) {
        // For chains, initialize with first template's variables
        const initialVars = {};
        item.templates[0].variables.forEach(variable => {
          initialVars[variable.name] = item.templates[0].default_values?.[variable.name] || '';
        });
        setVariables(initialVars);
      }
    }
  }, [item, itemType, availableModels]);

  // Reset test result when item changes
  useEffect(() => {
    setTestResult(null);
    setRating(0);
    setNotes('');
  }, [item]);

  const handleParameterChange = (param, value) => {
    setParameters({
      ...parameters,
      [param]: value
    });
  };

  const handleVariableChange = (name, value) => {
    setVariables({
      ...variables,
      [name]: value
    });
  };

  const handleTest = async () => {
    if (!selectedModel) {
      alert('Please select a model');
      return;
    }
    
    setIsLoading(true);
    setTestResult(null);
    
    try {
      // In a real implementation, this would be an API call
      // const response = await fetch(`/api/prompts/${itemType}s/${item.id}/test`, {
      //   method: 'POST',
      //   headers: {
      //     'Content-Type': 'application/json',
      //   },
      //   body: JSON.stringify({
      //     model: selectedModel,
      //     parameters,
      //     variables
      //   }),
      // });
      // const data = await response.json();
      // setTestResult(data);
      
      // Mock test result for demonstration
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const mockResult = {
        id: Math.floor(Math.random() * 10000),
        created_at: new Date().toISOString(),
        model: selectedModel,
        parameters: parameters,
        variables_used: variables,
        execution_time: Math.random() * 2 + 0.5,
        rating: null,
        notes: null
      };
      
      if (itemType === 'template') {
        // Generate a mock prompt by replacing variables in the template
        let promptText = item.template_text;
        Object.entries(variables).forEach(([name, value]) => {
          const regex = new RegExp(`\\{\\{${name}\\}\\}|\\{${name}\\}`, 'g');
          promptText = promptText.replace(regex, value || `[${name}]`);
        });
        
        mockResult.prompt_text = promptText;
        mockResult.response_text = `This is a simulated response for the prompt: "${promptText}"\n\nThe response would contain AI-generated content based on your prompt template and the variables you provided. In a real implementation, this would be generated by the ${selectedModel} model with the parameters you specified.\n\nTemperature: ${parameters.temperature}\nMax Tokens: ${parameters.max_tokens}\n\nThis is just a placeholder for demonstration purposes.`;
      } else {
        // For chains, generate mock intermediate results
        mockResult.intermediate_results = [];
        
        for (let i = 0; i < item.templates.length; i++) {
          const template = item.templates[i];
          
          // Generate a mock prompt for this step
          let promptText = template.template_text;
          
          // For first step, use provided variables
          if (i === 0) {
            Object.entries(variables).forEach(([name, value]) => {
              const regex = new RegExp(`\\{\\{${name}\\}\\}|\\{${name}\\}`, 'g');
              promptText = promptText.replace(regex, value || `[${name}]`);
            });
          } 
          // For subsequent steps, use previous response
          else {
            const prevResponse = mockResult.intermediate_results[i-1].response;
            promptText = promptText.replace(/\{\{previous_response\}\}|\{previous_response\}/g, prevResponse);
            
            // Also replace any other variables that might be in the template
            Object.entries(variables).forEach(([name, value]) => {
              const regex = new RegExp(`\\{\\{${name}\\}\\}|\\{${name}\\}`, 'g');
              promptText = promptText.replace(regex, value || `[${name}]`);
            });
          }
          
          const stepResult = {
            step: i + 1,
            template_id: template.id,
            template_title: template.title,
            prompt: promptText,
            response: `This is a simulated response for step ${i+1} using template "${template.title}".\n\nIn a real implementation, this would be the output from the ${selectedModel} model for this step in the chain.`,
            execution_time: Math.random() * 1 + 0.3,
            success: true
          };
          
          mockResult.intermediate_results.push(stepResult);
        }
        
        mockResult.final_result = mockResult.intermediate_results[mockResult.intermediate_results.length - 1].response;
      }
      
      setTestResult(mockResult);
    } catch (error) {
      console.error('Error testing prompt:', error);
      alert('Error testing prompt. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleRateResult = async () => {
    if (!testResult) return;
    
    try {
      // In a real implementation, this would be an API call
      // await fetch(`/api/prompts/${itemType}s/test-results/${testResult.id}/rate`, {
      //   method: 'POST',
      //   headers: {
      //     'Content-Type': 'application/json',
      //   },
      //   body: JSON.stringify({
      //     rating,
      //     notes
      //   }),
      // });
      
      // Update local state
      setTestResult({
        ...testResult,
        rating,
        notes
      });
      
      // Notify parent component
      if (onSaveResult) {
        onSaveResult({
          ...testResult,
          rating,
          notes
        });
      }
      
      alert('Rating saved successfully!');
    } catch (error) {
      console.error('Error saving rating:', error);
      alert('Error saving rating. Please try again.');
    }
  };

  const handleCopyToClipboard = (text) => {
    navigator.clipboard.writeText(text).then(() => {
      setCopiedToClipboard(true);
      setTimeout(() => setCopiedToClipboard(false), 2000);
    });
  };

  const handleShareToLibrary = () => {
    if (!testResult) return;
    
    if (onShareToLibrary) {
      onShareToLibrary(item, testResult);
    }
  };

  const renderStarRating = () => {
    return (
      <div className="star-rating">
        {[1, 2, 3, 4, 5].map(star => (
          <span
            key={star}
            onClick={() => setRating(star)}
            className={star <= rating ? 'star-filled' : 'star-empty'}
          >
            {star <= rating ? <FaStar /> : <FaRegStar />}
          </span>
        ))}
      </div>
    );
  };

  return (
    <div className="prompt-testing-interface">
      <div className="testing-header">
        <h2>Test {itemType === 'template' ? 'Prompt Template' : 'Prompt Chain'}</h2>
        <div className="item-title">{item?.title}</div>
      </div>
      
      <div className="testing-container">
        <div className="testing-form">
          <div className="form-section">
            <h3>Model Settings</h3>
            <div className="form-group">
              <label htmlFor="model-select">Model</label>
              <select
                id="model-select"
                value={selectedModel}
                onChange={(e) => setSelectedModel(e.target.value)}
              >
                <option value="">Select a model</option>
                {availableModels.map(model => (
                  <option key={model.id} value={model.id}>
                    {model.name}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="form-group">
              <label htmlFor="temperature">
                Temperature: {parameters.temperature}
              </label>
              <input
                id="temperature"
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={parameters.temperature}
                onChange={(e) => handleParameterChange('temperature', parseFloat(e.target.value))}
              />
              <div className="parameter-description">
                Higher values make output more random, lower values more deterministic
              </div>
            </div>
            
            <div className="advanced-parameters-toggle" onClick={() => setShowAdvancedParams(!showAdvancedParams)}>
              {showAdvancedParams ? 'Hide Advanced Parameters' : 'Show Advanced Parameters'}
            </div>
            
            {showAdvancedParams && (
              <div className="advanced-parameters">
                <div className="form-group">
                  <label htmlFor="max-tokens">
                    Max Tokens: {parameters.max_tokens}
                  </label>
                  <input
                    id="max-tokens"
                    type="range"
                    min="64"
                    max="4096"
                    step="64"
                    value={parameters.max_tokens}
                    onChange={(e) => handleParameterChange('max_tokens', parseInt(e.target.value))}
                  />
                </div>
                
                <div className="form-group">
                  <label htmlFor="top-p">
                    Top P: {parameters.top_p}
                  </label>
                  <input
                    id="top-p"
                    type="range"
                    min="0"
                    max="1"
                    step="0.05"
                    value={parameters.top_p}
                    onChange={(e) => handleParameterChange('top_p', parseFloat(e.target.value))}
                  />
                </div>
                
                <div className="form-group">
                  <label htmlFor="frequency-penalty">
                    Frequency Penalty: {parameters.frequency_penalty}
                  </label>
                  <input
                    id="frequency-penalty"
                    type="range"
                    min="0"
                    max="2"
                    step="0.1"
                    value={parameters.frequency_penalty}
                    onChange={(e) => handleParameterChange('frequency_penalty', parseFloat(e.target.value))}
                  />
                </div>
                
                <div className="form-group">
                  <label htmlFor="presence-penalty">
                    Presence Penalty: {parameters.presence_penalty}
                  </label>
                  <input
                    id="presence-penalty"
                    type="range"
                    min="0"
                    max="2"
                    step="0.1"
                    value={parameters.presence_penalty}
                    onChange={(e) => handleParameterChange('presence_penalty', parseFloat(e.target.value))}
                  />
                </div>
              </div>
            )}
          </div>
          
          {Object.keys(variables).length > 0 && (
            <div className="form-section">
              <h3>Variables</h3>
              {Object.entries(variables).map(([name, value]) => (
                <div key={name} className="form-group">
                  <label htmlFor={`var-${name}`}>{name}</label>
                  <input
                    id={`var-${name}`}
                    type="text"
                    value={value}
                    onChange={(e) => handleVariableChange(name, e.target.value)}
                    placeholder={`Value for ${name}`}
                  />
                </div>
              ))}
            </div>
          )}
          
          <div className="form-actions">
            <button
              className="test-button"
              onClick={handleTest}
              disabled={isLoading}
            >
              <FaFlask /> {isLoading ? 'Testing...' : 'Run Test'}
            </button>
          </div>
        </div>
        
        <div className="testing-results">
          {isLoading ? (
            <div className="loading-indicator">
              <div className="spinner"></div>
              <p>Testing your {itemType}...</p>
            </div>
          ) : testResult ? (
            <div className="result-container">
              <div className="result-header">
                <h3>Test Results</h3>
                <div className="result-meta">
                  <div className="meta-item">
                    <span className="meta-label">Model:</span>
                    <span className="meta-value">{testResult.model}</span>
                  </div>
                  <div className="meta-item">
                    <span className="meta-label">Time:</span>
                    <span className="meta-value">{testResult.execution_time.toFixed(2)}s</span>
                  </div>
                </div>
              </div>
              
              {itemType === 'template' ? (
                <>
                  <div className="result-section">
                    <div className="section-header">
                      <h4>Prompt</h4>
                      <button 
                        className="copy-button"
                        onClick={() => handleCopyToClipboard(testResult.prompt_text)}
                        title="Copy to clipboard"
                      >
                        <FaClipboard />
                      </button>
                    </div>
                    <div className="prompt-display">
                      <pre>{testResult.prompt_text}</pre>
                    </div>
                  </div>
                  
                  <div className="result-section">
                    <div className="section-header">
                      <h4>Response</h4>
                      <button 
                        className="copy-button"
                        onClick={() => handleCopyToClipboard(testResult.response_text)}
                        title="Copy to clipboard"
                      >
                        <FaClipboard />
                      </button>
                    </div>
                    <div className="response-display">
                      <pre>{testResult.response_text}</pre>
                    </div>
                  </div>
                </>
              ) : (
                <>
                  <div clas
(Content truncated due to size limit. Use line ranges to read in chunks)